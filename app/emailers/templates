# app/emailers/templates.py
# Email body/subject helpers used by the orchestrator after parsing.
# Standalone utility (does not send email); integrates with your existing smtp_oauth.

from __future__ import annotations
from typing import Dict, List

SUBJECT_PREFIX = "[Earnings Watch]"


def _fmt_metric(name: str, m: dict | None) -> str:
    if not m:
        return ""
    parts: List[str] = []
    cur = m.get("current")
    yoy = m.get("yoy")
    if cur:
        parts.append(str(cur))
    if yoy:
        parts.append(f"YoY: {yoy}")
    return f"{name.upper()}: " + ", ".join(parts) if parts else ""


def render_subject(payload: Dict[str, object]) -> str:
    headline = str(payload.get("headline") or "Update")
    return f"{SUBJECT_PREFIX} {headline}"


def render_body(payload: Dict[str, object]) -> str:
    lines: List[str] = []
    lines.append(f"Headline: {payload.get('headline','')}")
    lines.append(f"URL: {payload.get('final_url','')}")
    lines.append("")
    lines.append(f"Summary: {payload.get('short_summary','')}")
    lines.append("")

    # Highlights
    highs = payload.get("key_highlights") or []
    if highs:
        lines.append("Key Highlights:")
        for h in highs:
            lines.append(f" - {h}")
        lines.append("")

    # Metrics (respect the keys used by extract.py)
    for key in ("revenue", "ebitda", "net_income", "eps"):
        s = _fmt_metric(key, payload.get(key))
        if s:
            lines.append(s)

    # Optional notes
    ft = payload.get("final_thoughts")
    if ft:
        lines.append("")
        lines.append(f"Notes: {ft}")

    return "\n".join(lines) + "\n"
